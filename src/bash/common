#!/bin/bash

WHITE='\033[1;37m'
BLACK='\033[0;30m'
RED='\033[0;31m'
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
DARK_GRAY='\033[1;30m'
BROWN_ORANGE='\033[0;33m'
LIGHT_GRAY='\033[0;37m'
LIGHT_RED='\033[1;31m'
LIGHT_GREEN='\033[1;32m'
LIGHT_BLUE='\033[1;34m'
LIGHT_PURPLE='\033[1;35m'
LIGHT_CYAN='\033[1;36m'
NC='\033[0m' # No Color

vpn_type=${1:-UNKNOWN}
cloud=${2:-UNKNOWN}
command=${3:-UNKNOWN}

function usage() {
  echo -e "${NC}\nUSAGE: vs <VPN_TYPE> <CLOUD> <COMMAND> [options]\n"
  echo -e "  This CLI manages VPN cloud servers in multiple cloud regions.\n${LIGHT_GREEN}"
  echo -e "  <COMMAND>  This should be one of the following:\n${DARK_GRAY}"
  echo -e "    show-regions    show regions servers can be created in"
  echo -e "    deploy-server   deploys or updates a VPN server"
  echo -e "    destroy-server  destroys a VPN server"
  echo -e "    list-servers    lists all deployed servers and their status"
  echo -e "    start-server    starts a server that has been shut-down"
  echo -e "    start-tunnel    starts a server that has been shut-down"
  echo -e "${NC}"
}

function common::set_working_dir() {

  working_dir=$(pwd)
  while [[ $working_dir != / ]]; do    
    if [[ -e $working_dir/.workspace ]]; then
      break
    fi
    working_dir=$(dirname $working_dir)
  done

  if [[ $working_dir == / ]]; then
    working_dir=$(pwd)
    mkdir -p $working_dir/.workspace    
  fi
}

function common::validate() {

  set +e
  which aws >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find AWS CLI in the system path.\n" 
    echo -e "${GREEN}Please follow the instructions at: "
    echo -e "- ${BLUE}https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html\n" 
    echo -e "${GREEN}to download and install the AWS CLI."
    echo -e "${NC}"
    exit 1
  fi
  which gcloud >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find Google Cloud CLI in the system path.\n" 
    echo -e "${GREEN}Please follow the instructions at: "
    echo -e "- ${BLUE}https://cloud.google.com/sdk/docs\n" 
    echo -e "${GREEN}to download and install the Google Cloud SDK."
    echo -e "${NC}"
    exit 1
  fi
  which az >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find Microsoft Azure CLI in the system path.\n" 
    echo -e "${GREEN}Please follow the instructions at: "
    echo -e "- ${BLUE}https://docs.microsoft.com/en-us/cli/azure/install-azure-cli\n" 
    echo -e "${GREEN}to download and install the Microsoft Azure CLI."
    echo -e "${NC}"
    exit 1
  fi
  which terraform >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find Terraform CLI in the system path.\n" 
    echo -e "${GREEN}Please download the CLI from:"
    echo -e "- ${BLUE}https://www.terraform.io/downloads.html\n" 
    echo -e "${GREEN}and unzip and copy it to a system path location such as"
    echo -e "'/usr/local/bin'."
    echo -e "${NC}"
    exit 1
  fi
  which jq >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find JQ CLI in the system path.\n" 
    echo -e "${GREEN}Please download the CLI from:"
    echo -e "- ${BLUE}https://stedolan.github.io/jq/\n" 
    echo -e "${GREEN}rename it to 'jq' and copy it to a system path location such as"
    echo -e "'/usr/local/bin'."
    echo -e "${NC}"
    exit 1
  fi
  set -e

  if [[ ! -e $root_dir/cloud/recipes/$vpn_type ]]; then
    echo -e "${RED}\nERROR! Unknown VPN type.\n" 
    echo -e "${GREEN}Available VPN types for deployment are:\n"
    for d in $(find $root_dir/cloud/recipes -type d -depth 1 -print); do 
      echo "- \"$(basename $d)\"" 
    done
    echo -e "${NC}"
    exit 1
  fi
  if [[ ! -e $root_dir/cloud/recipes/$vpn_type/$cloud ]]; then
    echo -e "${RED}\nERROR! Unknown cloud target for VPN of type \"$vpn_type\".\n" 
    echo -e "${GREEN}Cloud targets available for deployment are:\n"
    for d in $(find $root_dir/cloud/recipes/$vpn_type -type d -depth 1 -print); do 
      echo "- \"$(basename $d)\"" 
    done
    echo -e "${NC}"
    exit 1
  fi
  if [[ ! -e $working_dir/cloud-credentials ]]; then
    echo -e "${RED}\nERROR! Unable to find the Cloud Credentials file at \"$working_dir/cloud-credentials\".\n" 
    exit 1
  fi
  if [[ ! -e $working_dir/deployment-vars ]]; then
    echo -e "${RED}\nERROR! Unable to find the Deployment variables file at \"$working_dir/deployment-vars\".\n" 
    exit 1
  fi
}

function common::initialize() {

  common::set_working_dir
  common::validate

  # Read the deployment context
  source $working_dir/cloud-credentials
  source $working_dir/deployment-vars

  template_dir=$root_dir/cloud/recipes/$vpn_type/$cloud
  workspace_dir=$working_dir/.workspace/$vpn_type/$cloud
  mkdir -p $workspace_dir
}

function common::validate_value_from_list() {

  local list=$1
  local value=$2
  local error_message=$3

  set +e
  echo "$list" | grep $value >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! ${error_message}${NC}"
    exit 1
  fi
  set -e
}

function terraform::set_cloud_region() {

  local vpn_type=$1
  local cloud=$2
  local region=$3

  case $cloud in
    aws)
      regions=$(aws ec2 describe-regions --query "Regions[].{Name:RegionName}" --output text)
      common::validate_value_from_list \
        "$regions" "$region" \
        "Unknown AWS region \"$region\"."

      export AWS_DEFAULT_REGION=$region
      ;;

    google)
      regions=$(gcloud compute regions list | awk '$1 != "NAME" { print $1 }')
      common::validate_value_from_list \
        "$regions" "$region" \
        "Unknown Azure region \"$region\"."
      ;;

    azure)
      regions=$(az account list-locations -o table | awk '$4 != "Name" && $0 !~ /^-.*/ { print substr($0, 48) }')
      common::validate_value_from_list \
        "$regions" "$region" \
        "Unknown Google Cloud region \"$region\"."
      ;;
  esac

  export TF_VAR_region=$region
}

function terraform::init() {

  local vpn_type=$1
  local cloud=$2
  local region=$3
  local template_dir=$4

  bucket_name=${TF_VAR_name}-vs-tfstate-${region}

  case $cloud in
    aws)
      # Check/Create Terraform state bucket
      set +e
      aws s3 ls | grep "${bucket_name}" >/dev/null 2>&1
      if [[ $? -ne 0 ]]; then
        echo -e "${GREEN}\nCreating AWS S3 state bucket \"${bucket_name}\" to save terraform deployment state...${NC}"
        aws s3 mb s3://${bucket_name} --region $region >/dev/null 2>&1
      fi
      set -e

      # Initialize Terraform
      echo -e "${GREEN}Initializing terraform context...${NC}"
      terraform init \
        -backend-config="key=${vpn_type}" \
        -backend-config="bucket=${bucket_name}" \
        $template_dir
      echo
      ;;

    google)
      # Check/Create Terraform state bucket
      set +e
      gsutil ls | awk -F'/' '{ print $3 }' >/dev/null 2>&1
      if [[ $? -ne 0 ]]; then
        echo -e "${GREEN}\nCreating Google Storage state bucket \"${bucket_name}\" to save terraform deployment state...${NC}"
        gsutil mb gs://${bucket_name} -l $region >/dev/null 2>&1
      fi
      set -e

      # Initialize Terraform
      echo -e "${GREEN}Initializing terraform context...${NC}"
      terraform init \
        -backend-config="prefix=${vpn_type}" \
        -backend-config="bucket=${bucket_name}" \
        $template_dir
      echo
      ;;

    # azure))
    #   ;;
  esac

  # Seems to be a bug in terraform where 'output' and 'taint' command are 
  # unable to load the backend state when the working directory does not 
  # have the backend resource template file.
  local backend_type=$(cat .terraform/terraform.tfstate | jq -r .backend.type)
  cat << ---EOF > backend.tf
terraform {
  backend "$backend_type" {}
}
---EOF
}

function terraform::apply() {

  local vpn_type=$1
  local cloud=$2
  local region=$3
  local template_dir=$4

  echo -e "${GREEN}Deploying VPN server type \"${vpn_type}\" to region \"${region}\" of \"$cloud\" cloud...${NC}"

  # Apply Terraform template and filter out
  # any output values for security purposes.
  terraform apply -auto-approve $template_dir 2>&1 \
    | tee apply.log | awk '/Outputs:/ {l=999}; (l-- > 0) {next} 1'

  # Save Terraform output in a JSON file for
  # later reference.
  terraform output -json \
     -state=.terraform/terraform.tfstate > output.json
}

function terraform::destroy() {

  local vpn_type=$1
  local cloud=$2
  local region=$3
  local template_dir=$4

  echo -e "${GREEN}Destroying VPN server type \"${vpn_type}\" deployed to region \"${region}\" of \"$cloud\" cloud...${NC}"

  # Apply Terraform template and filter out
  # any output values for security purposes.
  terraform destroy -auto-approve \
    -state=.terraform/terraform.tfstate \
    $template_dir 2>&1 | tee apply.log

  rm -fr output.json
}
