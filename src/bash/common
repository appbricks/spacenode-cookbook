#!/bin/bash

WHITE='\033[1;37m'
BLACK='\033[0;30m'
RED='\033[0;31m'
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
DARK_GRAY='\033[1;30m'
BROWN_ORANGE='\033[0;33m'
LIGHT_GRAY='\033[0;37m'
LIGHT_RED='\033[1;31m'
LIGHT_GREEN='\033[1;32m'
LIGHT_BLUE='\033[1;34m'
LIGHT_PURPLE='\033[1;35m'
LIGHT_CYAN='\033[1;36m'
NC='\033[0m' # No Color

BOLD='\033[1m'
NORMAL='\033[22m'
DIM='\033[2m'

function usage() {
  echo -e "${NC}\nUSAGE: vs ${BOLD}<COMMAND>${NORMAL} [options]\n"
  echo -e "  This CLI manages personal cloud VPN nodes in multiple cloud regions.\n"
  echo -e "${LIGHT_BLUE}  ${BOLD}<COMMAND>${NORMAL} should be one of the following:\n${GREEN}"
  echo -e "    ${BOLD}init${NORMAL}                                     Initializes the current folder with the"
  echo -e "                                             control files which contain the environment"
  echo -e "                                             for running deployment scripts."
  echo -e "    ${BOLD}show-regions${NORMAL}         <CLOUD>             Show regions nodes can be created in."
  echo -e "    ${BOLD}deploy-node${NORMAL}          <VPN_TYPE> <CLOUD>  Deploys or updates a personal VPN node."
  echo -e "    ${BOLD}destroy-node${NORMAL}         <VPN_TYPE> <CLOUD>  Destroys a VPN node."
  echo -e "    ${BOLD}download-vpn-config${NORMAL}  <VPN_TYPE> <CLOUD>  Downloads the client VPN configuration."
  #echo -e "    ${BOLD}start-tunnel${NORMAL}                             Starts tunnel services which obfuscate VPN traffic to a node."
  echo -e "    ${BOLD}show-nodes${NORMAL}                               Show all deployed nodes and their status.${NC}"
}

function common::set_working_dir() {

  working_dir=$(pwd)
  while [[ $working_dir != / ]]; do    
    if [[ -e $working_dir/.workspace ]]; then
      break
    fi
    working_dir=$(dirname $working_dir)
  done

  if [[ $working_dir == / ]]; then
    working_dir=$(pwd)
    mkdir -p $working_dir/.workspace    
  fi

  template_dir=$root_dir/cloud/recipes
  workspace_dir=$working_dir/.workspace
}

function common::validate_environment() {

  set +e
  which aws >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find AWS CLI in the system path.\n" 
    echo -e "${GREEN}Please follow the instructions at: "
    echo -e "- ${BLUE}https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html\n" 
    echo -e "${GREEN}to download and install the AWS CLI.${NC}"
    exit 1
  fi
  which gcloud >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find Google Cloud CLI in the system path.\n" 
    echo -e "${GREEN}Please follow the instructions at: "
    echo -e "- ${BLUE}https://cloud.google.com/sdk/docs\n" 
    echo -e "${GREEN}to download and install the Google Cloud SDK.${NC}"
    exit 1
  fi
  which az >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find Microsoft Azure CLI in the system path.\n" 
    echo -e "${GREEN}Please follow the instructions at: "
    echo -e "- ${BLUE}https://docs.microsoft.com/en-us/cli/azure/install-azure-cli\n" 
    echo -e "${GREEN}to download and install the Microsoft Azure CLI.${NC}"
    exit 1
  fi
  which terraform >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find Terraform CLI in the system path.\n" 
    echo -e "${GREEN}Please download the CLI from:"
    echo -e "- ${BLUE}https://www.terraform.io/downloads.html\n" 
    echo -e "${GREEN}and unzip and copy it to a system path location such as"
    echo -e "'/usr/local/bin'.${NC}"
    exit 1
  fi
  which jq >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! Unable to find JQ CLI in the system path.\n" 
    echo -e "${GREEN}Please download the CLI from:"
    echo -e "- ${BLUE}https://stedolan.github.io/jq/\n" 
    echo -e "${GREEN}rename it to 'jq' and copy it to a system path location such as"
    echo -e "'/usr/local/bin'.${NC}"
    exit 1
  fi
  set -e

  if [[ ! -e $working_dir/cloud-credentials ]]; then
    echo -e "${RED}\nERROR! Unable to find the Cloud Credentials file at \"$working_dir/cloud-credentials\".${NC}" 
    exit 1
  fi
  if [[ ! -e $working_dir/deployment-vars ]]; then
    echo -e "${RED}\nERROR! Unable to find the Deployment variables file at \"$working_dir/deployment-vars\".${NC}" 
    exit 1
  fi

  # Read the deployment context
  source $working_dir/cloud-credentials
  source $working_dir/deployment-vars
}

function common::validate_workspace() {

  if [[ ! -e $root_dir/cloud/recipes/$vpn_type ]]; then
    echo -e "${RED}\nERROR! Unknown VPN type.\n" 
    echo -e "${GREEN}Available VPN types for deployment are:\n"
    for d in $(find $root_dir/cloud/recipes -type d -depth 1 -print); do 
      echo "- \"$(basename $d)\"" 
    done
    echo -e "${NC}"
    exit 1
  fi
  if [[ ! -e $root_dir/cloud/recipes/$vpn_type/$cloud ]]; then
    echo -e "${RED}\nERROR! Unknown cloud target for VPN of type \"$vpn_type\".\n" 
    echo -e "${GREEN}Cloud targets available for deployment are:\n"
    for d in $(find $root_dir/cloud/recipes/$vpn_type -type d -depth 1 -print); do 
      echo "- \"$(basename $d)\"" 
    done
    echo -e "${NC}"
    exit 1
  fi

  template_dir=${template_dir}/${vpn_type}/${cloud}
  workspace_dir=${workspace_dir}/${vpn_type}/${cloud}
  mkdir -p $workspace_dir
}

function common::validate_value_from_list() {

  local list=$1
  local value=$2
  local error_message=$3

  set +e
  echo "$list" | grep $value >/dev/null 2>&1
  if [[ $? -ne 0 ]]; then
    echo -e "${RED}\nERROR! ${error_message}${NC}"
    exit 1
  fi
  set -e
}

function terraform::set_cloud_region() {

  local vpn_type=$1
  local cloud=$2
  local region=$3

  case $cloud in
    aws)
      regions=$(aws ec2 describe-regions --query "Regions[].{Name:RegionName}" --output text)
      common::validate_value_from_list \
        "$regions" "$region" \
        "Unknown AWS region \"$region\"."

      export AWS_DEFAULT_REGION=$region
      ;;
    azure)
      regions=$(az account list-locations -o table | awk '$4 != "Name" && $0 !~ /^-.*/ { print substr($0, 48) }')
      common::validate_value_from_list \
        "$regions" "$region" \
        "Unknown Azure Cloud region \"$region\"."
      ;;
    google)
      regions=$(gcloud compute regions list | awk '$1 != "NAME" { print $1 }')
      common::validate_value_from_list \
        "$regions" "$region" \
        "Unknown Azure region \"$region\"."
      ;;
  esac

  export TF_VAR_region=$region
}

function terraform::init() {

  local vpn_type=$1
  local cloud=$2
  local region=$3
  local template_dir=$4

  bucket_name=${TF_VAR_name}-vs-tfstate-${region}

  case $cloud in
    aws)
      # Check/Create Terraform state bucket
      set +e
      aws s3 ls | grep "${bucket_name}" >/dev/null 2>&1
      if [[ $? -ne 0 ]]; then
        echo -e "${GREEN}\nCreating AWS S3 state bucket \"${bucket_name}\" to save terraform deployment state...${NC}"
        aws s3 mb s3://${bucket_name} --region $region
      fi
      set -e

      # Initialize Terraform
      echo -e "${GREEN}Initializing terraform context...${NC}"
      terraform init \
        -backend-config="key=${vpn_type}" \
        -backend-config="bucket=${bucket_name}" \
        $template_dir
      echo
      ;;

    google)
      # Check/Create Terraform state bucket
      set +e
      gsutil ls | awk -F'/' '{ print $3 }' | grep "${bucket_name}" >/dev/null 2>&1
      if [[ $? -ne 0 ]]; then
        echo -e "${GREEN}\nCreating Google Storage state bucket \"${bucket_name}\" to save terraform deployment state...${NC}"
        gsutil mb -l $region gs://${bucket_name}
      fi
      set -e

      # Initialize Terraform
      echo -e "${GREEN}Initializing terraform context...${NC}"
      terraform init \
        -backend-config="prefix=${vpn_type}" \
        -backend-config="bucket=${bucket_name}" \
        $template_dir
      echo
      ;;

    azure)
      set +e
      az group list \
        | jq -r '.[].name' | grep default >/dev/null 2>&1
      if [[ $? -ne 0 ]]; then
        echo -e "${GREEN}\nCreating Azure resource group \"default\" in region \"$region\"...${NC}"
        az group create \
          --name default \
          --location "${region}" \
          --output none
      fi
      storage_account=vsstate${region}
      az storage account list \
        | jq -r '.[].name' | grep "${storage_account}" >/dev/null 2>&1
      if [[ $? -ne 0 ]]; then
        echo -e "${GREEN}\nCreating Azure Storage account \"${storage_account}\" to save terraform deployment state in...${NC}"
        az storage account create \
          --name "${storage_account}" \
          --location "${region}" \
          --resource-group default \
          --sku Standard_LRS \
          --output none
      fi
      container_name="${TF_VAR_name}"
      az storage container list --account-name "${storage_account}" \
        | jq -r '.[].name' | grep "${container_name}" >/dev/null 2>&1
      if [[ $? -ne 0 ]]; then
        echo -e "${GREEN}\nCreating Azure container \"${container_name}\" in storage account \"${storage_account}\" to save terraform deployment state in...${NC}"
        az storage container create \
          --name "${container_name}" \
          --account-name "${storage_account}" \
          --output none
      fi
      set -e

      # Initialize Terraform
      echo -e "${GREEN}Initializing terraform context...${NC}"
      terraform init \
        -backend-config="resource_group_name=default" \
        -backend-config="container_name=${container_name}" \
        -backend-config="key=terraform.tfstate" \
        -backend-config="storage_account_name=${storage_account}" \
        $template_dir
      echo
      ;;
  esac

  # Seems to be a bug in terraform where 'output' and 'taint' command are 
  # unable to load the backend state when the working directory does not 
  # have the backend resource template file.
  local backend_type=$(cat .terraform/terraform.tfstate | jq -r .backend.type)
  cat << ---EOF > backend.tf
terraform {
  backend "$backend_type" {}
}
---EOF
}

function terraform::apply() {

  local vpn_type=$1
  local cloud=$2
  local region=$3
  local template_dir=$4

  echo -e "${GREEN}Deploying VPN node type \"${vpn_type}\" to region \"${region}\" of \"$cloud\" cloud...${NC}"

  # Apply Terraform template and filter out
  # any output values for security purposes.
  terraform apply -auto-approve $template_dir 2>&1 \
    | tee apply.log | awk '/Outputs:/ {l=999}; (l-- > 0) {next} 1'

  # Save Terraform output in a JSON file for
  # later reference.
  terraform output -json \
     -state=.terraform/terraform.tfstate > output.json
}

function terraform::taint_bastion() {

  local vpn_type=$1
  local cloud=$2
  local region=$3
  local template_dir=$4

  echo -e "${GREEN}Flagging VPN node type \"${vpn_type}\" in region \"${region}\" of \"$cloud\" cloud to be rebuilt...${NC}"

  case $cloud in
    aws)
      terraform taint module.bootstrap.aws_instance.bastion
      ;;
    azure)
      terraform taint module.bootstrap.azurerm_virtual_machine.bastion
      ;;
    google)
      terraform taint module.bootstrap.google_compute_instance.bastion
      ;;
  esac
}

function terraform::plan() {

  local vpn_type=$1
  local cloud=$2
  local region=$3
  local template_dir=$4

  echo -e "${GREEN}Showing deployment plan for VPN node type \"${vpn_type}\" in region \"${region}\" of \"$cloud\" cloud...${NC}"

  # Output Terraform plan
  terraform plan $template_dir
}

function terraform::destroy() {

  local vpn_type=$1
  local cloud=$2
  local region=$3
  local template_dir=$4

  echo -e "${GREEN}Destroying VPN node type \"${vpn_type}\" deployed to region \"${region}\" of \"$cloud\" cloud...${NC}"

  # Apply Terraform template and filter out
  # any output values for security purposes.
  terraform destroy -auto-approve \
    -state=.terraform/terraform.tfstate \
    $template_dir 2>&1 | tee apply.log

  rm -fr output.json
}

function cloud::nodes() {

  local workspace_dir=$1

  for o in $(find $workspace_dir -name "output.json" -type f -print); do

    node_name=$(cat $o | jq -r .bastion_fqdn.value)
    bastion_instance_id=$(cat $o | jq -r .bastion_instance_id.value)

    region_path=$(dirname $o)
    region=$(basename $region_path)
    cloud_path=$(dirname $region_path)
    cloud=$(basename $cloud_path)
    vpn_type_path=$(dirname $cloud_path)
    vpn_type=$(basename $vpn_type_path)

    case $cloud in
      aws)
        state=$(aws \
          ec2 describe-instances \
            --instance-ids "$bastion_instance_id" \
            --region "$region" \
          | jq -r '.Reservations[0].Instances[0].State.Name')
        ;;
      azure)
        azure_vm_state=$(az vm show --id "$bastion_instance_id" --show-details \
          | jq -r .powerState)
        case $azure_vm_state in
          'VM running')
            state=running
            ;;
          'VM stopped'|'VM deallocated')
            state=stopped
            ;;
          *)
            state="${azure_vm_state#* }"
            ;;
        esac
        ;;
      google)
        gcp_zone=$(gcloud compute zones list --format json \
          | jq -r --arg region "$region" \
            '[ .[] | select(.region | match($region)) | .name ] | sort | .[0]')
        gcp_state=$(gcloud compute instances describe \
          "$bastion_instance_id" --zone "$gcp_zone" --format json \
          | jq -r '.status | ascii_downcase')
        case $gcp_state in
          running)
            state=running
            ;;
          terminated)
            state=stopped
            ;;
          *)
            state=unknown
            ;;
        esac
        
        if [[ $state == terminated ]]; then
          # Stopped VMs in GCP are labeled as terminated
          state=stopped
        fi
        ;;
    esac
    echo "${vpn_type}|${cloud}|${region}|${node_name}|${state}|${bastion_instance_id}"
  done
}

function cloud::start_node() {

  local cloud=$1
  local region=$2
  local node_id=$3

  case $cloud in
    aws)
      aws ec2 start-instances --instance-ids "$node_id" --region "$region"
      ;;
    azure)
      az vm start --ids "${node_id}"
      ;;
    google)
      gcp_zone=$(gcloud compute zones list --format json \
        | jq -r --arg region "$region" \
          '[ .[] | select(.region | match($region)) | .name ] | sort | .[0]')
      gcloud compute instances start "$node_id" --zone="$gcp_zone"
      ;;
  esac
}

function cloud::stop_node() {

  local cloud=$1
  local region=$2
  local node_id=$3

  case $cloud in
    aws)
      aws ec2 stop-instances --instance-ids "$node_id" --region "$region"
      ;;
    azure)
      az vm stop --ids "${node_id}" 2>&1 >/dev/null
      az vm deallocate --ids "${node_id}" 2>&1 >/dev/null
      ;;
    google)
      gcp_zone=$(gcloud compute zones list --format json \
        | jq -r --arg region "$region" \
          '[ .[] | select(.region | match($region)) | .name ] | sort | .[0]')
      gcloud compute instances stop "$node_id" --zone="$gcp_zone"
      ;;
  esac
}

function ui::print_nodes_table() {

  local vpn_nodes=("$@")

  echo -e "     +----------+---------+----------------------+----------------------------------------------------+-------------+"
  echo -e "     | ${BOLD}VPN Type${NORMAL} | ${BOLD}Cloud${NORMAL}   | ${BOLD}Region${NORMAL}               | ${BOLD}Name${NORMAL}                                               | ${BOLD}Status${NORMAL}      |"
  echo -e "+----+----------+---------+----------------------+----------------------------------------------------+-------------+"

  for ((i=0; i<${#vpn_nodes[@]}; i++)); do
    node_detail=( $(echo "${vpn_nodes[$i]}" | sed "s/|/ /g") )
    printf "| %2d | %-8s | %-7s | %-20s | %-50s | %-11s |\n" \
      $i \
      ${node_detail[0]} \
      ${node_detail[1]} \
      ${node_detail[2]} \
      ${node_detail[3]} \
      ${node_detail[4]}
  done

  echo -e "+----+----------+---------+----------------------+----------------------------------------------------+-------------+"  
}